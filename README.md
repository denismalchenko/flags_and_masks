<h1>Библиотека flags.h</h1>

Эта библиотека позволяет реализовывать операции записи, чтения и изменения нескольких буллевых флагов, хранимых в одной целочисленной переменной. 
Реализованы операции как с одним отдельным флагом, так и с несколькими флагами одновременно по маске.

<h2>Содержание</h2>

1. [Введение](#part-i)
2. [Контракты](#part-ii)
3. [Описание](#part-iii)
   
   3.1. [Операции с одним флагом](#part-v)
   
   3.2. [Создание маски](#part-vv)
   
   3.3. [Операции по маске](#part-vvv)

<h2 id="part-i">Введение</h2>

Флаг - это индикатор состояния. У буллевого флага всего два состояния: 1 (True) и 0 (False). 
Таким образом для хранения состояния буллевого флага достаточно всего 1 бита. 
Если вашей программе нужно отслеживать несколько таких состояний, то наиболее эффективным способом хранения таких состояний является хранения состояния в определенных битах одной целочисленной переменной. Будем называть ее - флаговой переменной.

Работа с флаговыми переменными осуществляется при помощи битовых масок. Битовая маска похожа на флаговую переменную, т.к. в ней тоже хранятся 0 и 1 на битах соответствующих флагам. 
Главное отличие битовой маски от флаговой переменной смысл этих битов. Во флаговой переменной каждый бит отвечает за текущее состояние флага. 
В битовой маске каждый бит означает с каким флагом сейчас будет происходить работа (чтение, установка, сброс, изменение): 1 - с этим флагом будет работа, 0 - этот флаг не будет использован.
Поэтому битовые маски часто являются константами и их значение известно на этапе компиляции, поэтому их удобно определять через `#define`.

Кроме флаговой переменной широко распространены и другие спосбы хранения флагов, например, в структуре или массиве.
По сравнению с этими способами флаговая переменная имеет следующие преимущества:
* Высокую скорость всех операций.
* Удобную работу (чтение, установка, сброс, изменение) одновременно с несколькими флагами.
* Возможность использовать `switch-case` конструкцию, вместо `else if` конструкции.
* Экономия памяти.

Использование флаговых переменных подразумевает использование битовых операций. Это ухудшает читабельность кода. 

Эта библиотека разработана специально, чтобы улучшить читабельность кода, сохранив все премущества битовых переменных.
Такой функционал стал возможен за счёт использования макросов, которые для пользователя выглядят как функции, но на этапе компиляции, на их место будет вставлен соответствующие битовые операции.

<h2 id="part-ii">Контракты</h2>

* Типы переменных
  Для флаговых переменных и битовых масок не вводится новый тип. Для их объявлении и инициализации можно использовать любые целочисленные типы переменных.
  Использование других типов может привести к ошибке компиляции или к UB (Undefined Behavior - неопределенное поведение).
  При указании номера бита (в [операциях с одним флагом](#part-v) и в [MASK_FROM_BITS](#part-vv)) также нужно использовать целочисленный тип, причем вы должны быть уверенны, что его значение неотрицательно. Это нарушение также может привести к ошибке компиляции или к UB.
* Ограничение размера
* Порядок бит
* Операции с переменными

<h2 id="part-iii">Описание</h2>

<h3 id="part-v">Операции с одним флагом</h3>
* GET_BIT(flags, n)
* GET_BIT_BOOL(flags, n)
* SET_BIT(flags, n)
* CLEAR_BIT(flags, n)
* TOGGLE_BIT(flags, n)

<h3 id="part-vv">Создание маски</h3>
* MASK_FROM_BITS(...)
* MERGE_MASKS(...)
* CROSS_MASKS(...)
* INVERSE_FLAGS(flags)

<h3 id="part-vvv">Операции по маске</h3>
* GET_BITMASK_OR(flags, mask)
* GET_BITMASK_OR_BOOL(flags, mask)
* GET_BITMASK_AND(flags, mask)
* SET_BITMASK(flags, mask)
* CLEAR_BITMASK(flags, mask)
* TOGGLE_BITMASK(flags, mask)
