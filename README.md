<h1>Библиотека flags.h</h1>

Эта библиотека позволяет реализовывать операции записи, чтения и изменения нескольких булевых флагов, хранимых в одной целочисленной переменной. 
Реализованы операции как с одним отдельным флагом, так и с несколькими флагами одновременно по маске.

<h2>Содержание</h2>

1. [Введение](#part-i)
2. [Контракты](#part-ii)
3. [Описание](#part-iii)
   
   3.1. [Операции с одним флагом](#part-v)
   
   3.2. [Создание маски](#part-vv)
   
   3.3. [Операции по маске](#part-vvv)

<h2 id="part-i">Введение</h2>

Флаг - это индикатор состояния. У булевого флага всего два состояния: 1 (True, флаг поднят/установлен) и 0 (False, флаг опущен/снят). 
Таким образом для хранения состояния булевого флага достаточно всего 1 бита. 
Если вашей программе нужно отслеживать несколько таких состояний, то наиболее эффективным способом хранения таких состояний является хранения состояния в определенных битах одной целочисленной переменной. Будем называть ее - флаговой переменной.

Работа с флаговыми переменными осуществляется при помощи битовых масок. Битовая маска похожа на флаговую переменную, т.к. в ней тоже хранятся 0 и 1 на битах соответствующих флагам. 
Главное отличие битовой маски от флаговой переменной смысл этих битов. Во флаговой переменной каждый бит отвечает за текущее состояние флага. 
В битовой маске каждый бит означает с каким флагом сейчас будет происходить работа (чтение, установка, сброс, изменение): 1 - с этим флагом будет работа, 0 - этот флаг не будет использован.
Поэтому битовые маски часто являются константами и их значение известно на этапе компиляции, поэтому их удобно определять через `#define`.

Кроме флаговой переменной широко распространены и другие способы хранения флагов, например, в структуре или массиве.
По сравнению с этими способами флаговая переменная имеет следующие преимущества:
* Высокую скорость всех операций.
* Удобную работу (чтение, установка, сброс, изменение) одновременно с несколькими флагами.
* Возможность использовать `switch-case` конструкцию, вместо `else if` конструкции.
* Экономия памяти.

Использование флаговых переменных подразумевает использование битовых операций. Это ухудшает читабельность кода. 

Эта библиотека разработана специально, чтобы улучшить читабельность кода, сохранив все преимущества битовых переменных.
Такой функционал стал возможен за счёт использования макросов, которые для пользователя выглядят как функции, но на этапе компиляции, на их место будет вставлен соответствующие битовые операции.

<h2 id="part-ii">Контракты</h2>

* Типы переменных\
  Для флаговых переменных и битовых масок не вводится новый тип. Для их объявления и инициализации можно использовать любые целочисленные типы переменных.
  Использование других типов может привести к ошибке компиляции или к UB (Undefined Behavior - неопределенное поведение).\
  При указании номера бита (в [операциях с одним флагом](#part-v) и в [MASK_FROM_BITS](#part-vv)) также нужно использовать целочисленный тип, причем вы должны быть уверенны, что его значение неотрицательно. Это нарушение также может привести к ошибке компиляции или к UB.
* Ограничение размера\
  Максимальное количество флагов, которое может хранить флаговая переменная, ограничено ее типом и совпадает с размером типа в битах. Так переменные типа long содержат как минимум 32 бита, а значит гарантированно могут хранить 32 флага. Точное значение зависит от платформы. Чтобы точно определить максимальный размер вы можете:
  - Вычислить значение с помощью выражения `8 * sizeof(flags)`, где flags - название вашей флаговой переменной или её тип. Однако результат может отличаться на разных платформах.
  - Использовать типы из библиотеки `stdint.h`.
  - Использовать наибольшие по размеру целочисленные типы `long long` или `unsigned long long`, которые гарантировано содержат 64 бита.

  Значение номера бита (в [операциях с одним флагом](#part-v) и в [MASK_FROM_BITS](#part-vv)) должно лежать в пределах от `0` до `8 * sizeof(flags) - 1` (т.е. на единицу меньше размера флаговой переменной flags битах к которой применяется). Выход за эти значения приведет к ошибке компиляции или к UB.
* Порядок бит\
  Пользователь самостоятельно определяет номер бита в котором будет храниться флаг. Нумерация битов начинается с `0` и идет до `8 * sizeof(flags) - 1` (т.е. на единицу меньше размера флаговой переменной flags битах). При этом расположение, плотность и порядок заполнения никак не влияют на производительность. Например, если необходимо хранить 3 флага, то первый флаг может храниться в 0 бите, второй может в 3 бите, а третий - в 7 бите. Хотя чаще выбирают последовательное заполнение от 0.\
  Выбрав номера бит для хранения флагов, критически важно его придерживаться. Ошибка с нумерацией приведет к UB, которое тяжело обнаруживается. Чтобы уменьшить вероятность такой ошибки, рекомендуется все номера битов обозначить через `#define` и в коде обращаться только через введенные макросы.
* Операции с переменными\
  Правильное поведение флаговых переменных возможно, если к ним применяются только операции из этой библиотеки и присваивание между собой и масками. Однако т.к. это стандартные целочисленные типы, то им может быть присвоено любое целое число (в пределах ограничений своего типа), а также они могут быть изменены с помощью операторов инкремента (`++`), декремента (`--`), арифметических операций с присваиванием (`+=`, `-=`, `*=`, `\=`, `%=`), побитовых операций с присваиванием (`&=`, `|=`, `^=`, `<<=` `>>=`). Применение арифметических операций с присваиванием почти наверняка сломает правильное поведение программы, а использование присваивание числу, и использование побитовых операций с присваиванием возможно, но не рекомендуется во избежание UB, т.к. все необходимые операции уже заложены в библиотеке.

<h2 id="part-iii">Описание</h2>

<h3 id="part-v">Операции с одним флагом</h3>

* `GET_BIT(flags, n)`\
Получить значение флага на месте n-ого бита. 
  - `0` - если флаг опущен, 
  - `не 0` - если поднят.
* `GET_BIT_BOOL(flags, n)`\
Получить значение флага на месте n-ого бита. Работает на одно битовое действие медленнее, чем GET_BIT(flags, n).
  - `0` - если флаг опущен, 
  - `1` - если поднят.
* `SET_BIT(flags, n)`\
Устанавливает флаг на месте n-ого бита. Флаг поднят.
* `CLEAR_BIT(flags, n)`\
Снимает флаг на месте n-ого бита. Флаг опущен.
* `TOGGLE_BIT(flags, n)`\
Меняет значение флага на месте n-ого бита на противоположное. Поднятый флаг опускается, а опущенный - поднимается.

<h3 id="part-vv">Создание маски</h3>

* `MASK_FROM_BITS(...)`\
Формирует маску по номерам битов. Может быть перечислено до 8 бит. Это означает, что операции по маске будут происходить именно с этими битами.
* `MERGE_MASKS(...)`\
Объединяет маски, т.е. если бит выбран хотя бы в одной маске, то в перечисленной он тоже будет выбран. Может быть перечислено до 8 масок.
* `CROSS_MASKS(...)`\
Пересекает маски, т.е. бит будет выбран, если только она выбран во всех масках. Может быть перечислено до 8 масок.
* `INVERSE_BITS(flags)`\
Меняет все биты во флаговой переменной или маске. Для флаговой переменной это означает, что все опущенные флаги станут поднятыми, а поднятые - опустятся. Для маски это означает, что работа будет происходить только с оставшимися битами.

<h3 id="part-vvv">Операции по маске</h3>

* `GET_BITMASK_OR(flags, mask)`\
Проверяет подняты ли флаги, соответствующие маске. 
  - `0` - если все флаги опущены, 
  - `не 0` - если поднят хотя бы один из флагов по маске.
* `GET_BITMASK_OR_BOOL(flags, mask)`\
Проверяет подняты ли флаги, соответствующие маске. Работает на одно логическое действие медленнее, чем GET_BITMASK_OR(flags, mask).
  - `0` - если все флаги по маске опущены, 
  - `1` - если поднят хотя бы один из флагов по маске.
* `GET_BITMASK_AND(flags, mask)`\
Проверяет подняты ли флаги, соответствующие маске. 
  - `0` - если хотя бы один флаг по маске не поднят, 
  - `1` - если подняты все флаги по маске.
* `SET_BITMASK(flags, mask)`\
Устанавливает флаги по маске. Все флаги, перечисленные в маске, поднимаются, значения остальных флагов не меняется.
* `CLEAR_BITMASK(flags, mask)`\
Снимает флаги по маске. Все флаги, перечисленные в маске, опускаются, значения остальных флагов не меняется.
* `TOGGLE_BITMASK(flags, mask)`\
Меняет значение флагов по маске на противоположное. Все флаги, перечисленные в маске, поднимаются, если были опущены и опускаются, если были подняты, а значения остальных флагов не меняется.